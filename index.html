#include <WiFi.h>
#include <PubSubClient.h>

// WiFi Configuration
const char* ssid = "Innovation_Lab";
const char* password = "Mlp0Zaq1";

// MQTT Configuration
const char* mqtt_broker = "broker.emqx.io";
const int mqtt_port = 1883;
const char* base_topic = "smart_innovation_lab_ecb_eice";

// Generate random client ID to avoid collisions
String mqtt_client_id = "ESP32_Relay_" + String(random(0xffff), HEX);

// GPIO Configuration (8 relays, ACTIVE HIGH)
const int RELAY_PINS[8] = {13, 12, 14, 27, 26, 25, 33, 32};
const int SWITCH_PINS[8] = {23, 22, 21, 19, 18, 5, 17, 16};

// Debounce configuration
const unsigned long DEBOUNCE_DELAY = 50;
unsigned long lastDebounceTime[8] = {0};
bool lastSwitchState[8] = {LOW};
bool currentSwitchState[8] = {LOW};

// Relay states
bool relayStates[8] = {false};

WiFiClient espClient;
PubSubClient client(espClient);

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n\n================================");
  Serial.println("ESP32 MQTT Relay Control System");
  Serial.println("================================\n");
  
  // Initialize relay pins (OUTPUT, start LOW)
  for (int i = 0; i < 8; i++) {
    pinMode(RELAY_PINS[i], OUTPUT);
    digitalWrite(RELAY_PINS[i], LOW);
    relayStates[i] = false;
  }
  
  // Initialize switch pins (INPUT)
  for (int i = 0; i < 8; i++) {
    pinMode(SWITCH_PINS[i], INPUT);
  }
  
  // Step 1: Connect to WiFi
  connectWiFi();
  
  // Step 2: Setup MQTT and connect
  client.setServer(mqtt_broker, mqtt_port);
  client.setCallback(mqttCallback);
  client.setKeepAlive(10);
  connectMQTT();
  
  // Step 3: Subscribe to topics
  String system_topic = String(base_topic) + "/system/all";
  String relay_cmd_topic = String(base_topic) + "/relay/+/cmd";
  client.subscribe(system_topic.c_str());
  client.subscribe(relay_cmd_topic.c_str());
  Serial.println("Subscribed to system/all and relay/+/cmd");
  
  delay(100);
  
  // Step 4: Read physical switch states and apply
  readPhysicalSwitches();
  applyPhysicalSwitchStates();
  
  // Step 5: Wait for retained messages (system/all check)
  Serial.println("Waiting for retained messages...");
  for (int i = 0; i < 20; i++) {
    client.loop();
    delay(50);
  }
  
  // Step 6: Publish final relay states
  publishAllRelayStates();
  
  Serial.println("\n✓ System ready - entering normal operation\n");
}

void loop() {
  // Maintain MQTT connection
  if (!client.connected()) {
    connectMQTT();
  }
  client.loop();
  
  // Check physical switches
  checkPhysicalSwitches();
  
  delay(10);
}

void connectWiFi() {
  Serial.print("Connecting to WiFi: ");
  Serial.println(ssid);
  
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n✓ WiFi connected");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\n✗ WiFi connection failed");
  }
}

void connectMQTT() {
  while (!client.connected()) {
    Serial.print("Connecting to MQTT broker:  ");
    Serial.println(mqtt_broker);
    
    String status_topic = String(base_topic) + "/device/status";
    
    // CORRECT SYNTAX: Pass LWT parameters directly to connect()
    // connect(clientID, willTopic, willQoS, willRetain, willMessage)
    if (client.connect(mqtt_client_id. c_str(), 
                       status_topic.c_str(),  // LWT topic
                       0,                      // LWT QoS = 0
                       true,                   // LWT Retain = true
                       "offline")) {           // LWT Message = "offline"
      
      Serial.println("✓ MQTT connected");
      Serial.print("Client ID: ");
      Serial.println(mqtt_client_id);
      
      // Immediately publish "online" to override any stale "offline"
      delay(100);
      client.publish(status_topic.c_str(), "online", true);
      Serial.println("✓ Published device/status = online (retained)");
      
      // Process any pending messages
      delay(100);
      client.loop();
      
    } else {
      Serial.print("✗ MQTT connection failed, rc=");
      Serial.println(client.state());
      delay(2000);
    }
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String topicStr = String(topic);
  String message = "";
  
  for (unsigned int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  
  Serial.print("[MQTT] Received [");
  Serial.print(topic);
  Serial.print("]: ");
  Serial.println(message);
  
  // Handle system/all command
  if (topicStr. endsWith("/system/all")) {
    if (message == "ALL_OFF") {
      executeAllOff();
    } else if (message == "") {
      Serial.println("[MQTT] ALL_OFF cleared");
    }
    return;
  }
  
  // Handle individual relay commands
  if (topicStr.indexOf("/relay/") >= 0 && topicStr.endsWith("/cmd")) {
    // Extract relay number from topic:  . ../relay/X/cmd
    int relayStart = topicStr.indexOf("/relay/") + 7;
    int relayEnd = topicStr.indexOf("/cmd");
    String relayNumStr = topicStr.substring(relayStart, relayEnd);
    int relayNum = relayNumStr.toInt();
    
    if (relayNum >= 1 && relayNum <= 8) {
      int idx = relayNum - 1;
      
      if (message == "ON") {
        setRelay(idx, true);
        publishRelayState(idx);
      } else if (message == "OFF") {
        setRelay(idx, false);
        publishRelayState(idx);
      }
    }
  }
}

void executeAllOff() {
  Serial.println("\n⚠️  EXECUTING ALL_OFF ⚠️ ");
  
  for (int i = 0; i < 8; i++) {
    if (relayStates[i]) {  // Only turn OFF if currently ON
      setRelay(i, false);
      publishRelayState(i);
      delay(50);
    }
  }
  
  Serial.println("✓ ALL_OFF complete\n");
}

void setRelay(int idx, bool state) {
  relayStates[idx] = state;
  digitalWrite(RELAY_PINS[idx], state ? HIGH : LOW);
  
  Serial.print("[Relay] Relay ");
  Serial.print(idx + 1);
  Serial.print(" set to ");
  Serial.println(state ? "ON" : "OFF");
}

void publishRelayState(int idx) {
  String state_topic = String(base_topic) + "/relay/" + String(idx + 1) + "/state";
  String state_value = relayStates[idx] ? "ON" : "OFF";
  
  client.publish(state_topic.c_str(), state_value.c_str(), true);
  
  Serial.print("[Publish] Relay ");
  Serial.print(idx + 1);
  Serial.print(" state: ");
  Serial.println(state_value);
}

void publishAllRelayStates() {
  Serial.println("Publishing all relay states...");
  for (int i = 0; i < 8; i++) {
    publishRelayState(i);
    delay(50);
  }
}

void readPhysicalSwitches() {
  Serial.println("Reading physical switch states...");
  for (int i = 0; i < 8; i++) {
    currentSwitchState[i] = digitalRead(SWITCH_PINS[i]);
    lastSwitchState[i] = currentSwitchState[i];
  }
}

void applyPhysicalSwitchStates() {
  Serial.println("Applying physical switch states to relays...");
  for (int i = 0; i < 8; i++) {
    bool switchOn = currentSwitchState[i] == HIGH;
    setRelay(i, switchOn);
    Serial.print("  Switch ");
    Serial.print(i + 1);
    Serial.print(": ");
    Serial.println(switchOn ? "ON" : "OFF");
  }
}

void checkPhysicalSwitches() {
  for (int i = 0; i < 8; i++) {
    bool reading = digitalRead(SWITCH_PINS[i]);
    
    // Debounce logic
    if (reading != lastSwitchState[i]) {
      lastDebounceTime[i] = millis();
    }
    
    if ((millis() - lastDebounceTime[i]) > DEBOUNCE_DELAY) {
      if (reading != currentSwitchState[i]) {
        currentSwitchState[i] = reading;
        
        // Switch state changed - update relay
        bool switchOn = (reading == HIGH);
        Serial.print("[Switch] Switch ");
        Serial.print(i + 1);
        Serial.print(" changed to:  ");
        Serial.println(switchOn ? "ON" : "OFF");
        
        setRelay(i, switchOn);
        publishRelayState(i);
      }
    }
    
    lastSwitchState[i] = reading;
  }
}
